// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseAssert_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Assert_Statement), "Assert_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ASSERT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSERT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSERT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpressionEquality(node);

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseBeep_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Beep_Statement), "Beep_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.BEEP);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BEEP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BEEP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            while (tok.Type == TokenType.OPP4
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.INFINITY
                || tok.Type == TokenType.LPAREN
                || tok.Type == TokenType.VARIABLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.SMARTQUOTESTRING
                || tok.Type == TokenType.ROOT
                || tok.Type == TokenType.SINCLAIROP
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.INPUT)
            {

                
                ParseExpression(node);

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpression(node);
            tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCall_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Call_Statement), "Call_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.CALL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CALL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CALL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseVariableOrFunctionCall(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCls_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Cls_Statement), "Cls_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.CLS);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CLS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COLOR, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            if (tok.Type == TokenType.COLOR
                || tok.Type == TokenType.OPP4
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.INFINITY
                || tok.Type == TokenType.LPAREN
                || tok.Type == TokenType.VARIABLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.SMARTQUOTESTRING
                || tok.Type == TokenType.ROOT
                || tok.Type == TokenType.SINCLAIROP
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.INPUT)
            {

                
                tok = scanner.LookAhead(TokenType.COLOR, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
                switch (tok.Type)
                {
                    case TokenType.COLOR:
                        tok = scanner.Scan(TokenType.COLOR);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.COLOR) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.OPP4:
                    case TokenType.NUMBER:
                    case TokenType.HEX:
                    case TokenType.INFINITY:
                    case TokenType.LPAREN:
                    case TokenType.VARIABLE:
                    case TokenType.STRING:
                    case TokenType.SMARTQUOTESTRING:
                    case TokenType.ROOT:
                    case TokenType.SINCLAIROP:
                    case TokenType.MINUS:
                    case TokenType.INPUT:
                        ParseExpression(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }

                
                tok = scanner.LookAhead(TokenType.COLOR, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
                if (tok.Type == TokenType.COLOR
                    || tok.Type == TokenType.OPP4
                    || tok.Type == TokenType.NUMBER
                    || tok.Type == TokenType.HEX
                    || tok.Type == TokenType.INFINITY
                    || tok.Type == TokenType.LPAREN
                    || tok.Type == TokenType.VARIABLE
                    || tok.Type == TokenType.STRING
                    || tok.Type == TokenType.SMARTQUOTESTRING
                    || tok.Type == TokenType.ROOT
                    || tok.Type == TokenType.SINCLAIROP
                    || tok.Type == TokenType.MINUS
                    || tok.Type == TokenType.INPUT)
                {
                    tok = scanner.LookAhead(TokenType.COLOR, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
                    switch (tok.Type)
                    {
                        case TokenType.COLOR:
                            tok = scanner.Scan(TokenType.COLOR);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.COLOR) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.OPP4:
                        case TokenType.NUMBER:
                        case TokenType.HEX:
                        case TokenType.INFINITY:
                        case TokenType.LPAREN:
                        case TokenType.VARIABLE:
                        case TokenType.STRING:
                        case TokenType.SMARTQUOTESTRING:
                        case TokenType.ROOT:
                        case TokenType.SINCLAIROP:
                        case TokenType.MINUS:
                        case TokenType.INPUT:
                            ParseExpression(node);
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseConsole_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Console_Statement), "Console_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.CONSOLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CONSOLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CONSOLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            if (tok.Type == TokenType.OPP4
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.INFINITY
                || tok.Type == TokenType.LPAREN
                || tok.Type == TokenType.VARIABLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.SMARTQUOTESTRING
                || tok.Type == TokenType.ROOT
                || tok.Type == TokenType.SINCLAIROP
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.INPUT)
            {

                
                ParseExpression(node);

                
                tok = scanner.LookAhead(TokenType.COMMA);
                while (tok.Type == TokenType.COMMA)
                {

                    
                    tok = scanner.Scan(TokenType.COMMA);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMMA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseExpression(node);
                tok = scanner.LookAhead(TokenType.COMMA);
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseData_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Data_Statement), "Data_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.DATA);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DATA) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DATA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseConstantList(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseDim_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Dim_Statement), "Dim_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.DIM);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DIM) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIM.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            if (tok.Type == TokenType.OPP4
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.INFINITY
                || tok.Type == TokenType.LPAREN
                || tok.Type == TokenType.VARIABLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.SMARTQUOTESTRING
                || tok.Type == TokenType.ROOT
                || tok.Type == TokenType.SINCLAIROP
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.INPUT)
            {
                ParseExpression(node);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseDump_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Dump_Statement), "Dump_Statement");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.DUMP);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DUMP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DUMP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFor_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.For_Statement), "For_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.EQUALS);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EQUALS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpression(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpression(node);

            
            tok = scanner.LookAhead(TokenType.STEP);
            if (tok.Type == TokenType.STEP)
            {

                
                tok = scanner.Scan(TokenType.STEP);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.STEP) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STEP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpression(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseForever_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Forever_Statement), "Forever_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FOREVER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOREVER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOREVER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.STOP, TokenType.WAIT);
            if (tok.Type == TokenType.STOP
                || tok.Type == TokenType.WAIT)
            {
                tok = scanner.LookAhead(TokenType.STOP, TokenType.WAIT);
                switch (tok.Type)
                {
                    case TokenType.STOP:
                        tok = scanner.Scan(TokenType.STOP);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.STOP) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STOP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.WAIT:
                        tok = scanner.Scan(TokenType.WAIT);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.WAIT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WAIT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFunction_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Function_Statement), "Function_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FUNCTION);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FUNCTION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FUNCTION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.VARIABLE);
            if (tok.Type == TokenType.VARIABLE)
            {

                
                tok = scanner.Scan(TokenType.VARIABLE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.VARIABLE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.COMMA);
                while (tok.Type == TokenType.COMMA)
                {

                    
                    tok = scanner.Scan(TokenType.COMMA);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMMA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.Scan(TokenType.VARIABLE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.VARIABLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                tok = scanner.LookAhead(TokenType.COMMA);
                }
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseGlobal_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Global_Statement), "Global_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.GLOBAL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.GLOBAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GLOBAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseGosub_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Gosub_Statement), "Gosub_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.GOSUB);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.GOSUB) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GOSUB.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.INTEGER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.INTEGER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseGoto_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Goto_Statement), "Goto_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.GOTO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.GOTO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GOTO.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.INTEGER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.INTEGER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseElse_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Else_Statement), "Else_Statement");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.ELSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ELSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseEndIf_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.EndIf_Statement), "EndIf_Statement");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.ENDIF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ENDIF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDIF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseIf_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.If_Statement), "If_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpression(node);

            
            tok = scanner.LookAhead(TokenType.THEN);
            if (tok.Type == TokenType.THEN)
            {

                
                tok = scanner.Scan(TokenType.THEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.THEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.THEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseStatement(node);

                
                tok = scanner.LookAhead(TokenType.ELSE);
                if (tok.Type == TokenType.ELSE)
                {

                    
                    tok = scanner.Scan(TokenType.ELSE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ELSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseStatement(node);
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseImport_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Import_Statement), "Import_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IMPORT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IMPORT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IMPORT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.FUNCTIONS);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FUNCTIONS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FUNCTIONS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.FROM);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FROM) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseStringValue(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseInput_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Input_Statement), "Input_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.INPUT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.INPUT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INPUT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseLet_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Let_Statement), "Let_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.LET);
            if (tok.Type == TokenType.LET)
            {
                tok = scanner.Scan(TokenType.LET);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.LET) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            ParseVariableOrFunctionCall(node);

            
            tok = scanner.LookAhead(TokenType.EQUALS);
            if (tok.Type == TokenType.EQUALS)
            {

                
                tok = scanner.Scan(TokenType.EQUALS);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EQUALS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.COLOR, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
                switch (tok.Type)
                {
                    case TokenType.COLOR:
                        tok = scanner.Scan(TokenType.COLOR);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.COLOR) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.OPP4:
                    case TokenType.NUMBER:
                    case TokenType.HEX:
                    case TokenType.INFINITY:
                    case TokenType.LPAREN:
                    case TokenType.VARIABLE:
                    case TokenType.STRING:
                    case TokenType.SMARTQUOTESTRING:
                    case TokenType.ROOT:
                    case TokenType.SINCLAIROP:
                    case TokenType.MINUS:
                    case TokenType.INPUT:
                        ParseExpression(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpression_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expression_Statement), "Expression_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.EQUALS);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EQUALS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpression(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseNext_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Next_Statement), "Next_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.NEXT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NEXT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEXT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePaper_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Paper_Statement), "Paper_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PAPER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PAPER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAPER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COLOR, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            switch (tok.Type)
            {
                case TokenType.COLOR:
                    tok = scanner.Scan(TokenType.COLOR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COLOR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.OPP4:
                case TokenType.NUMBER:
                case TokenType.HEX:
                case TokenType.INFINITY:
                case TokenType.LPAREN:
                case TokenType.VARIABLE:
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:
                case TokenType.ROOT:
                case TokenType.SINCLAIROP:
                case TokenType.MINUS:
                case TokenType.INPUT:
                    ParseExpression(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePause_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Pause_Statement), "Pause_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PAUSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PAUSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PAUSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpression(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePlay_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Play_Statement), "Play_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PLAY);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PLAY) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLAY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.STOP, TokenType.WAIT, TokenType.ONNOTE, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            switch (tok.Type)
            {
                case TokenType.STOP:
                    tok = scanner.Scan(TokenType.STOP);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STOP) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STOP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.WAIT:
                    tok = scanner.Scan(TokenType.WAIT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.WAIT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WAIT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.ONNOTE:

                    
                    tok = scanner.Scan(TokenType.ONNOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ONNOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ONNOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseExpression(node);
                    break;
                case TokenType.OPP4:
                case TokenType.NUMBER:
                case TokenType.HEX:
                case TokenType.INFINITY:
                case TokenType.LPAREN:
                case TokenType.VARIABLE:
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:
                case TokenType.ROOT:
                case TokenType.SINCLAIROP:
                case TokenType.MINUS:
                case TokenType.INPUT:
                    ParseExpression(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePrint_Expression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Print_Expression), "Print_Expression");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.AT);
            if (tok.Type == TokenType.AT)
            {

                
                tok = scanner.Scan(TokenType.AT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpression(node);

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpression(node);
            }

            
            ParseExpression(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePrint_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Print_Statement), "Print_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PRINT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PRINT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PRINT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParsePrint_Expression(node);

            
            tok = scanner.LookAhead(TokenType.COMMA, TokenType.SEMICOLON);
            while (tok.Type == TokenType.COMMA
                || tok.Type == TokenType.SEMICOLON)
            {

                
                tok = scanner.LookAhead(TokenType.COMMA, TokenType.SEMICOLON);
                switch (tok.Type)
                {
                    case TokenType.COMMA:
                        tok = scanner.Scan(TokenType.COMMA);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.COMMA) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.SEMICOLON:
                        tok = scanner.Scan(TokenType.SEMICOLON);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.SEMICOLON) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }

                
                tok = scanner.LookAhead(TokenType.AT, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
                if (tok.Type == TokenType.AT
                    || tok.Type == TokenType.OPP4
                    || tok.Type == TokenType.NUMBER
                    || tok.Type == TokenType.HEX
                    || tok.Type == TokenType.INFINITY
                    || tok.Type == TokenType.LPAREN
                    || tok.Type == TokenType.VARIABLE
                    || tok.Type == TokenType.STRING
                    || tok.Type == TokenType.SMARTQUOTESTRING
                    || tok.Type == TokenType.ROOT
                    || tok.Type == TokenType.SINCLAIROP
                    || tok.Type == TokenType.MINUS
                    || tok.Type == TokenType.INPUT)
                {
                    ParsePrint_Expression(node);
                }
            tok = scanner.LookAhead(TokenType.COMMA, TokenType.SEMICOLON);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseRand_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Rand_Statement), "Rand_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RAND);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RAND) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RAND.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpression(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseRead_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Read_Statement), "Read_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.READ);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.READ) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.READ.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseRem_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Rem_Statement), "Rem_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.REM);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REM) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REM.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.RESTOFLINE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RESTOFLINE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RESTOFLINE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseReturn_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Return_Statement), "Return_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RETURN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RETURN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RETURN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            if (tok.Type == TokenType.OPP4
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.INFINITY
                || tok.Type == TokenType.LPAREN
                || tok.Type == TokenType.VARIABLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.SMARTQUOTESTRING
                || tok.Type == TokenType.ROOT
                || tok.Type == TokenType.SINCLAIROP
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.INPUT)
            {
                ParseExpression(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSpeak_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Speak_Statement), "Speak_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SPEAK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SPEAK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPEAK.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.LIST, TokenType.VOICE, TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            switch (tok.Type)
            {
                case TokenType.LIST:

                    
                    tok = scanner.Scan(TokenType.LIST);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LIST) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LIST.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.Scan(TokenType.VOICES);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.VOICES) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VOICES.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.VOICE:
                case TokenType.OPP4:
                case TokenType.NUMBER:
                case TokenType.HEX:
                case TokenType.INFINITY:
                case TokenType.LPAREN:
                case TokenType.VARIABLE:
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:
                case TokenType.ROOT:
                case TokenType.SINCLAIROP:
                case TokenType.MINUS:
                case TokenType.INPUT:

                    
                    tok = scanner.LookAhead(TokenType.VOICE);
                    if (tok.Type == TokenType.VOICE)
                    {

                        
                        tok = scanner.Scan(TokenType.VOICE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.VOICE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VOICE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }

                        
                        ParseExpression(node);
                    }

                    
                    ParseExpression(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStop_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Stop_Statement), "Stop_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.END, TokenType.STOP);
            switch (tok.Type)
            {
                case TokenType.END:
                    tok = scanner.Scan(TokenType.END);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.END) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.END.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.STOP:
                    tok = scanner.Scan(TokenType.STOP);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STOP) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STOP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            if (tok.Type == TokenType.OPP4
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.INFINITY
                || tok.Type == TokenType.LPAREN
                || tok.Type == TokenType.VARIABLE
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.SMARTQUOTESTRING
                || tok.Type == TokenType.ROOT
                || tok.Type == TokenType.SINCLAIROP
                || tok.Type == TokenType.MINUS
                || tok.Type == TokenType.INPUT)
            {
                ParseExpression(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statement), "Statement");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.ASSERT, TokenType.BEEP, TokenType.CALL, TokenType.CLS, TokenType.CONSOLE, TokenType.DATA, TokenType.DIM, TokenType.DUMP, TokenType.ELSE, TokenType.ENDIF, TokenType.EQUALS, TokenType.FOR, TokenType.FOREVER, TokenType.FUNCTION, TokenType.GLOBAL, TokenType.GOSUB, TokenType.GOTO, TokenType.IF, TokenType.IMPORT, TokenType.INPUT, TokenType.LET, TokenType.VARIABLE, TokenType.NEXT, TokenType.PAPER, TokenType.PAUSE, TokenType.PLAY, TokenType.PRINT, TokenType.RAND, TokenType.READ, TokenType.REM, TokenType.RETURN, TokenType.SPEAK, TokenType.END, TokenType.STOP);
            switch (tok.Type)
            {
                case TokenType.ASSERT:
                    ParseAssert_Statement(node);
                    break;
                case TokenType.BEEP:
                    ParseBeep_Statement(node);
                    break;
                case TokenType.CALL:
                    ParseCall_Statement(node);
                    break;
                case TokenType.CLS:
                    ParseCls_Statement(node);
                    break;
                case TokenType.CONSOLE:
                    ParseConsole_Statement(node);
                    break;
                case TokenType.DATA:
                    ParseData_Statement(node);
                    break;
                case TokenType.DIM:
                    ParseDim_Statement(node);
                    break;
                case TokenType.DUMP:
                    ParseDump_Statement(node);
                    break;
                case TokenType.ELSE:
                    ParseElse_Statement(node);
                    break;
                case TokenType.ENDIF:
                    ParseEndIf_Statement(node);
                    break;
                case TokenType.EQUALS:
                    ParseExpression_Statement(node);
                    break;
                case TokenType.FOR:
                    ParseFor_Statement(node);
                    break;
                case TokenType.FOREVER:
                    ParseForever_Statement(node);
                    break;
                case TokenType.FUNCTION:
                    ParseFunction_Statement(node);
                    break;
                case TokenType.GLOBAL:
                    ParseGlobal_Statement(node);
                    break;
                case TokenType.GOSUB:
                    ParseGosub_Statement(node);
                    break;
                case TokenType.GOTO:
                    ParseGoto_Statement(node);
                    break;
                case TokenType.IF:
                    ParseIf_Statement(node);
                    break;
                case TokenType.IMPORT:
                    ParseImport_Statement(node);
                    break;
                case TokenType.INPUT:
                    ParseInput_Statement(node);
                    break;
                case TokenType.LET:
                case TokenType.VARIABLE:
                    ParseLet_Statement(node);
                    break;
                case TokenType.NEXT:
                    ParseNext_Statement(node);
                    break;
                case TokenType.PAPER:
                    ParsePaper_Statement(node);
                    break;
                case TokenType.PAUSE:
                    ParsePause_Statement(node);
                    break;
                case TokenType.PLAY:
                    ParsePlay_Statement(node);
                    break;
                case TokenType.PRINT:
                    ParsePrint_Statement(node);
                    break;
                case TokenType.RAND:
                    ParseRand_Statement(node);
                    break;
                case TokenType.READ:
                    ParseRead_Statement(node);
                    break;
                case TokenType.REM:
                    ParseRem_Statement(node);
                    break;
                case TokenType.RETURN:
                    ParseReturn_Statement(node);
                    break;
                case TokenType.SPEAK:
                    ParseSpeak_Statement(node);
                    break;
                case TokenType.END:
                case TokenType.STOP:
                    ParseStop_Statement(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFull_Statement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Full_Statement), "Full_Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            if (tok.Type == TokenType.WHITESPACE)
            {
                tok = scanner.Scan(TokenType.WHITESPACE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WHITESPACE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.LINE_NUMBER);
            if (tok.Type == TokenType.LINE_NUMBER)
            {
                tok = scanner.Scan(TokenType.LINE_NUMBER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.LINE_NUMBER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LINE_NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            ParseStatement(node);

            
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            while (tok.Type == TokenType.WHITESPACE)
            {
                tok = scanner.Scan(TokenType.WHITESPACE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WHITESPACE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseProgram(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Program), "Program");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.CR, TokenType.WHITESPACE);
            while (tok.Type == TokenType.CR
                || tok.Type == TokenType.WHITESPACE)
            {
                tok = scanner.LookAhead(TokenType.CR, TokenType.WHITESPACE);
                switch (tok.Type)
                {
                    case TokenType.CR:
                        tok = scanner.Scan(TokenType.CR);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.CR) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.WHITESPACE:
                        tok = scanner.Scan(TokenType.WHITESPACE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.WHITESPACE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            tok = scanner.LookAhead(TokenType.CR, TokenType.WHITESPACE);
            }

            
            ParseFull_Statement(node);

            
            tok = scanner.LookAhead(TokenType.CR);
            while (tok.Type == TokenType.CR)
            {

                
                tok = scanner.Scan(TokenType.CR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.CR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.WHITESPACE, TokenType.LINE_NUMBER, TokenType.ASSERT, TokenType.BEEP, TokenType.CALL, TokenType.CLS, TokenType.CONSOLE, TokenType.DATA, TokenType.DIM, TokenType.DUMP, TokenType.ELSE, TokenType.ENDIF, TokenType.EQUALS, TokenType.FOR, TokenType.FOREVER, TokenType.FUNCTION, TokenType.GLOBAL, TokenType.GOSUB, TokenType.GOTO, TokenType.IF, TokenType.IMPORT, TokenType.INPUT, TokenType.LET, TokenType.VARIABLE, TokenType.NEXT, TokenType.PAPER, TokenType.PAUSE, TokenType.PLAY, TokenType.PRINT, TokenType.RAND, TokenType.READ, TokenType.REM, TokenType.RETURN, TokenType.SPEAK, TokenType.END, TokenType.STOP);
                if (tok.Type == TokenType.WHITESPACE
                    || tok.Type == TokenType.LINE_NUMBER
                    || tok.Type == TokenType.ASSERT
                    || tok.Type == TokenType.BEEP
                    || tok.Type == TokenType.CALL
                    || tok.Type == TokenType.CLS
                    || tok.Type == TokenType.CONSOLE
                    || tok.Type == TokenType.DATA
                    || tok.Type == TokenType.DIM
                    || tok.Type == TokenType.DUMP
                    || tok.Type == TokenType.ELSE
                    || tok.Type == TokenType.ENDIF
                    || tok.Type == TokenType.EQUALS
                    || tok.Type == TokenType.FOR
                    || tok.Type == TokenType.FOREVER
                    || tok.Type == TokenType.FUNCTION
                    || tok.Type == TokenType.GLOBAL
                    || tok.Type == TokenType.GOSUB
                    || tok.Type == TokenType.GOTO
                    || tok.Type == TokenType.IF
                    || tok.Type == TokenType.IMPORT
                    || tok.Type == TokenType.INPUT
                    || tok.Type == TokenType.LET
                    || tok.Type == TokenType.VARIABLE
                    || tok.Type == TokenType.NEXT
                    || tok.Type == TokenType.PAPER
                    || tok.Type == TokenType.PAUSE
                    || tok.Type == TokenType.PLAY
                    || tok.Type == TokenType.PRINT
                    || tok.Type == TokenType.RAND
                    || tok.Type == TokenType.READ
                    || tok.Type == TokenType.REM
                    || tok.Type == TokenType.RETURN
                    || tok.Type == TokenType.SPEAK
                    || tok.Type == TokenType.END
                    || tok.Type == TokenType.STOP)
                {
                    ParseFull_Statement(node);
                }
            tok = scanner.LookAhead(TokenType.CR);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);

            ParseProgram(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStringValue(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StringValue), "StringValue");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.STRING, TokenType.SMARTQUOTESTRING);
            switch (tok.Type)
            {
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SMARTQUOTESTRING:
                    tok = scanner.Scan(TokenType.SMARTQUOTESTRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SMARTQUOTESTRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SMARTQUOTESTRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVariableOrFunctionCall(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VariableOrFunctionCall), "VariableOrFunctionCall");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.VARIABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VARIABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.LPAREN, TokenType.LSQUARE);
            if (tok.Type == TokenType.LPAREN
                || tok.Type == TokenType.LSQUARE)
            {
                tok = scanner.LookAhead(TokenType.LPAREN, TokenType.LSQUARE);
                switch (tok.Type)
                {
                    case TokenType.LPAREN:

                        
                        tok = scanner.Scan(TokenType.LPAREN);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.LPAREN) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }

                        
                        tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
                        if (tok.Type == TokenType.OPP4
                            || tok.Type == TokenType.NUMBER
                            || tok.Type == TokenType.HEX
                            || tok.Type == TokenType.INFINITY
                            || tok.Type == TokenType.LPAREN
                            || tok.Type == TokenType.VARIABLE
                            || tok.Type == TokenType.STRING
                            || tok.Type == TokenType.SMARTQUOTESTRING
                            || tok.Type == TokenType.ROOT
                            || tok.Type == TokenType.SINCLAIROP
                            || tok.Type == TokenType.MINUS
                            || tok.Type == TokenType.INPUT)
                        {

                            
                            ParseExpression(node);

                            
                            tok = scanner.LookAhead(TokenType.COMMA);
                            while (tok.Type == TokenType.COMMA)
                            {

                                
                                tok = scanner.Scan(TokenType.COMMA);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.COMMA) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }

                                
                                ParseExpression(node);
                            tok = scanner.LookAhead(TokenType.COMMA);
                            }
                        }

                        
                        tok = scanner.Scan(TokenType.RPAREN);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.RPAREN) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.LSQUARE:

                        
                        tok = scanner.Scan(TokenType.LSQUARE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.LSQUARE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LSQUARE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }

                        
                        ParseExpression(node);

                        
                        tok = scanner.Scan(TokenType.RSQUARE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.RSQUARE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RSQUARE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseConstant(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Constant), "Constant");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.STRING, TokenType.SMARTQUOTESTRING);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMBER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.HEX:
                    tok = scanner.Scan(TokenType.HEX);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.HEX) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HEX.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.INFINITY:
                    tok = scanner.Scan(TokenType.INFINITY);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INFINITY) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INFINITY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:
                    ParseStringValue(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseConstantList(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ConstantList), "ConstantList");
            parent.Nodes.Add(node);


            
            ParseConstant(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseConstant(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionAtom(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionAtom), "ExpressionAtom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMBER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.HEX:
                    tok = scanner.Scan(TokenType.HEX);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.HEX) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HEX.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.INFINITY:
                    tok = scanner.Scan(TokenType.INFINITY);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INFINITY) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INFINITY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.LPAREN:

                    
                    tok = scanner.Scan(TokenType.LPAREN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LPAREN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseExpression(node);

                    
                    tok = scanner.Scan(TokenType.RPAREN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.RPAREN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.VARIABLE:
                    ParseVariableOrFunctionCall(node);
                    break;
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:
                    ParseStringValue(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP12(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP12), "ExpressionP12");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                case TokenType.HEX:
                case TokenType.INFINITY:
                case TokenType.LPAREN:
                case TokenType.VARIABLE:
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:

                    
                    ParseExpressionAtom(node);

                    
                    tok = scanner.LookAhead(TokenType.POWER);
                    if (tok.Type == TokenType.POWER)
                    {
                        tok = scanner.Scan(TokenType.POWER);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.POWER) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POWER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }
                    break;
                case TokenType.ROOT:

                    
                    tok = scanner.Scan(TokenType.ROOT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ROOT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ROOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseExpressionP12(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP11(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP11), "ExpressionP11");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                case TokenType.HEX:
                case TokenType.INFINITY:
                case TokenType.LPAREN:
                case TokenType.VARIABLE:
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:
                case TokenType.ROOT:
                    ParseExpressionP12(node);
                    break;
                case TokenType.SINCLAIROP:

                    
                    tok = scanner.Scan(TokenType.SINCLAIROP);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SINCLAIROP) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINCLAIROP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseExpressionP11(node);
                    break;
                case TokenType.MINUS:

                    
                    tok = scanner.Scan(TokenType.MINUS);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.MINUS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MINUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseExpressionP11(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP10(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP10), "ExpressionP10");
            parent.Nodes.Add(node);


            
            ParseExpressionP11(node);

            
            tok = scanner.LookAhead(TokenType.OPP10);
            while (tok.Type == TokenType.OPP10)
            {

                
                tok = scanner.Scan(TokenType.OPP10);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPP10) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP10.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpressionP11(node);
            tok = scanner.LookAhead(TokenType.OPP10);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP9(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP9), "ExpressionP9");
            parent.Nodes.Add(node);


            
            ParseExpressionP10(node);

            
            tok = scanner.LookAhead(TokenType.OPP9);
            while (tok.Type == TokenType.OPP9)
            {

                
                tok = scanner.Scan(TokenType.OPP9);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPP9) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP9.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpressionP10(node);
            tok = scanner.LookAhead(TokenType.OPP9);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP6(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP6), "ExpressionP6");
            parent.Nodes.Add(node);


            
            ParseExpressionP9(node);

            
            tok = scanner.LookAhead(TokenType.OPP6);
            while (tok.Type == TokenType.OPP6)
            {

                
                tok = scanner.Scan(TokenType.OPP6);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPP6) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP6.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpressionP9(node);
            tok = scanner.LookAhead(TokenType.OPP6);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP5(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP5), "ExpressionP5");
            parent.Nodes.Add(node);


            
            ParseExpressionP6(node);

            
            tok = scanner.LookAhead(TokenType.OPP5);
            while (tok.Type == TokenType.OPP5)
            {

                
                tok = scanner.Scan(TokenType.OPP5);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPP5) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP5.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpressionP6(node);
            tok = scanner.LookAhead(TokenType.OPP5);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionEquality(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionEquality), "ExpressionEquality");
            parent.Nodes.Add(node);


            
            ParseExpressionP6(node);

            
            tok = scanner.Scan(TokenType.OPP5);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OPP5) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP5.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseExpressionP6(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP4(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP4), "ExpressionP4");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.OPP4);
            if (tok.Type == TokenType.OPP4)
            {
                tok = scanner.Scan(TokenType.OPP4);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPP4) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP4.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            ParseExpressionP5(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP3(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP3), "ExpressionP3");
            parent.Nodes.Add(node);


            
            ParseExpressionP4(node);

            
            tok = scanner.LookAhead(TokenType.OPP3);
            if (tok.Type == TokenType.OPP3)
            {

                
                tok = scanner.Scan(TokenType.OPP3);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPP3) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP3.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpressionP4(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpressionP2(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExpressionP2), "ExpressionP2");
            parent.Nodes.Add(node);


            
            ParseExpressionP3(node);

            
            tok = scanner.LookAhead(TokenType.OPP2);
            if (tok.Type == TokenType.OPP2)
            {

                
                tok = scanner.Scan(TokenType.OPP2);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OPP2) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPP2.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpressionP3(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseInputExpression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.InputExpression), "InputExpression");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.INPUT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.INPUT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INPUT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.DEFAULT);
            if (tok.Type == TokenType.DEFAULT)
            {

                
                tok = scanner.Scan(TokenType.DEFAULT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DEFAULT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DEFAULT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpression(node);
            }

            
            tok = scanner.LookAhead(TokenType.PROMPT);
            if (tok.Type == TokenType.PROMPT)
            {

                
                tok = scanner.Scan(TokenType.PROMPT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PROMPT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PROMPT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseExpression(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expression), "Expression");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.OPP4, TokenType.NUMBER, TokenType.HEX, TokenType.INFINITY, TokenType.LPAREN, TokenType.VARIABLE, TokenType.STRING, TokenType.SMARTQUOTESTRING, TokenType.ROOT, TokenType.SINCLAIROP, TokenType.MINUS, TokenType.INPUT);
            switch (tok.Type)
            {
                case TokenType.OPP4:
                case TokenType.NUMBER:
                case TokenType.HEX:
                case TokenType.INFINITY:
                case TokenType.LPAREN:
                case TokenType.VARIABLE:
                case TokenType.STRING:
                case TokenType.SMARTQUOTESTRING:
                case TokenType.ROOT:
                case TokenType.SINCLAIROP:
                case TokenType.MINUS:
                    ParseExpressionP2(node);
                    break;
                case TokenType.INPUT:
                    ParseInputExpression(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
