// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace TinyPG
{
    #region ParseTree
    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public int Code { get { return code; } }
        public int Line { get { return line; } }
        public int Column { get { return col; } }
        public int Position { get { return pos; } }
        public int Length { get { return length; } }
        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code,  0, node.Token.StartPos, node.Token.StartPos, node.Token.Length)
        {
        }

        public ParseError(string message, int code, int line, int col, int pos, int length)
        {
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }
    }

    // rootlevel of the node tree
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// this is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">additional optional input parameters</param>
        /// <returns>the output of the evaluation function</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }
    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        public List<ParseNode> Nodes { get {return nodes;} }
        
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text { // text to display in parse tree 
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;

            switch (Token.Type)
            {
                case TokenType.Assert_Statement:
                    Value = EvalAssert_Statement(tree, paramlist);
                    break;
                case TokenType.Beep_Statement:
                    Value = EvalBeep_Statement(tree, paramlist);
                    break;
                case TokenType.Call_Statement:
                    Value = EvalCall_Statement(tree, paramlist);
                    break;
                case TokenType.Cls_Statement:
                    Value = EvalCls_Statement(tree, paramlist);
                    break;
                case TokenType.Console_Statement:
                    Value = EvalConsole_Statement(tree, paramlist);
                    break;
                case TokenType.Data_Statement:
                    Value = EvalData_Statement(tree, paramlist);
                    break;
                case TokenType.Dim_Statement:
                    Value = EvalDim_Statement(tree, paramlist);
                    break;
                case TokenType.Dump_Statement:
                    Value = EvalDump_Statement(tree, paramlist);
                    break;
                case TokenType.For_Statement:
                    Value = EvalFor_Statement(tree, paramlist);
                    break;
                case TokenType.Forever_Statement:
                    Value = EvalForever_Statement(tree, paramlist);
                    break;
                case TokenType.Function_Statement:
                    Value = EvalFunction_Statement(tree, paramlist);
                    break;
                case TokenType.Global_Statement:
                    Value = EvalGlobal_Statement(tree, paramlist);
                    break;
                case TokenType.Gosub_Statement:
                    Value = EvalGosub_Statement(tree, paramlist);
                    break;
                case TokenType.Goto_Statement:
                    Value = EvalGoto_Statement(tree, paramlist);
                    break;
                case TokenType.Else_Statement:
                    Value = EvalElse_Statement(tree, paramlist);
                    break;
                case TokenType.EndIf_Statement:
                    Value = EvalEndIf_Statement(tree, paramlist);
                    break;
                case TokenType.If_Statement:
                    Value = EvalIf_Statement(tree, paramlist);
                    break;
                case TokenType.Import_Statement:
                    Value = EvalImport_Statement(tree, paramlist);
                    break;
                case TokenType.Input_Statement:
                    Value = EvalInput_Statement(tree, paramlist);
                    break;
                case TokenType.Let_Statement:
                    Value = EvalLet_Statement(tree, paramlist);
                    break;
                case TokenType.Expression_Statement:
                    Value = EvalExpression_Statement(tree, paramlist);
                    break;
                case TokenType.Next_Statement:
                    Value = EvalNext_Statement(tree, paramlist);
                    break;
                case TokenType.Paper_Statement:
                    Value = EvalPaper_Statement(tree, paramlist);
                    break;
                case TokenType.Pause_Statement:
                    Value = EvalPause_Statement(tree, paramlist);
                    break;
                case TokenType.Play_Statement:
                    Value = EvalPlay_Statement(tree, paramlist);
                    break;
                case TokenType.Print_Expression:
                    Value = EvalPrint_Expression(tree, paramlist);
                    break;
                case TokenType.Print_Statement:
                    Value = EvalPrint_Statement(tree, paramlist);
                    break;
                case TokenType.Rand_Statement:
                    Value = EvalRand_Statement(tree, paramlist);
                    break;
                case TokenType.Read_Statement:
                    Value = EvalRead_Statement(tree, paramlist);
                    break;
                case TokenType.Rem_Statement:
                    Value = EvalRem_Statement(tree, paramlist);
                    break;
                case TokenType.Return_Statement:
                    Value = EvalReturn_Statement(tree, paramlist);
                    break;
                case TokenType.Speak_Statement:
                    Value = EvalSpeak_Statement(tree, paramlist);
                    break;
                case TokenType.Stop_Statement:
                    Value = EvalStop_Statement(tree, paramlist);
                    break;
                case TokenType.Statement:
                    Value = EvalStatement(tree, paramlist);
                    break;
                case TokenType.Full_Statement:
                    Value = EvalFull_Statement(tree, paramlist);
                    break;
                case TokenType.Program:
                    Value = EvalProgram(tree, paramlist);
                    break;
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;
                case TokenType.StringValue:
                    Value = EvalStringValue(tree, paramlist);
                    break;
                case TokenType.VariableOrFunctionCall:
                    Value = EvalVariableOrFunctionCall(tree, paramlist);
                    break;
                case TokenType.Constant:
                    Value = EvalConstant(tree, paramlist);
                    break;
                case TokenType.ConstantList:
                    Value = EvalConstantList(tree, paramlist);
                    break;
                case TokenType.ExpressionAtom:
                    Value = EvalExpressionAtom(tree, paramlist);
                    break;
                case TokenType.ExpressionP12:
                    Value = EvalExpressionP12(tree, paramlist);
                    break;
                case TokenType.ExpressionP11:
                    Value = EvalExpressionP11(tree, paramlist);
                    break;
                case TokenType.ExpressionP10:
                    Value = EvalExpressionP10(tree, paramlist);
                    break;
                case TokenType.ExpressionP9:
                    Value = EvalExpressionP9(tree, paramlist);
                    break;
                case TokenType.ExpressionP6:
                    Value = EvalExpressionP6(tree, paramlist);
                    break;
                case TokenType.ExpressionP5:
                    Value = EvalExpressionP5(tree, paramlist);
                    break;
                case TokenType.ExpressionEquality:
                    Value = EvalExpressionEquality(tree, paramlist);
                    break;
                case TokenType.ExpressionP4:
                    Value = EvalExpressionP4(tree, paramlist);
                    break;
                case TokenType.ExpressionP3:
                    Value = EvalExpressionP3(tree, paramlist);
                    break;
                case TokenType.ExpressionP2:
                    Value = EvalExpressionP2(tree, paramlist);
                    break;
                case TokenType.InputExpression:
                    Value = EvalInputExpression(tree, paramlist);
                    break;
                case TokenType.Expression:
                    Value = EvalExpression(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        protected virtual object EvalAssert_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.AssertExpression (this.GetValue(tree, TokenType.ExpressionEquality, 0) as BCBasic.InfixExpression);
        }

        protected virtual object EvalBeep_Statement(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.Expression, 0) == null) return new BCBasic.Beep ();
        	return new BCBasic.Beep (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.Expression, 1) as BCBasic.IExpression);
        }

        protected virtual object EvalCall_Statement(ParseTree tree, params object[] paramlist)
        {
            var exp = this.GetValue(tree, TokenType.VariableOrFunctionCall, 0) as BCBasic.IExpression;
        	var vv = exp as BCBasic.VariableValue;
        	if (vv  != null)
        	{
        		// Make up for a parser deficiency.  User might have entered "CALL test" w/no parens,
        		// which comes here as a VariableValue.  In that case, redo it into a function.
        		exp = new BCBasic.NumericFunction (vv.VariableName);
        	}
        	return new BCBasic.Call(exp);
        }

        protected virtual object EvalCls_Statement(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.COLOR, 0) != null) return new BCBasic.Cls (this.GetValue(tree, TokenType.COLOR, 0) as string, this.GetValue(tree, TokenType.COLOR, 1) as string);
        	//if ($ INTEGER != null) return new BCBasic.Cls (Int32.Parse ($ INTEGER as string));
        	if (this.GetValue(tree, TokenType.Expression, 0) != null) return new BCBasic.Cls (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        	return new BCBasic.Cls();
        }

        protected virtual object EvalConsole_Statement(ParseTree tree, params object[] paramlist)
        {
            var cmd = new BCBasic.Console();
        	for (int i=0; i<99999; i++)
        	{
        		if (this.GetValue(tree, TokenType.Expression, i)==null) break;
        		cmd.AddExpression(this.GetValue(tree, TokenType.Expression, i) as BCBasic.IExpression);
        	}
        	return cmd;
        }

        protected virtual object EvalData_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Data (this.GetValue(tree, TokenType.ConstantList, 0) as IList<BCBasic.IExpression>);
        }

        protected virtual object EvalDim_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Dim (this.GetValue(tree, TokenType.VARIABLE, 0) as string, this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalDump_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Dump();
        }

        protected virtual object EvalFor_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.For (this.GetValue(tree, TokenType.VARIABLE, 0) as string, this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.Expression, 1) as BCBasic.IExpression, this.GetValue(tree, TokenType.Expression, 2) as BCBasic.IExpression);
        }

        protected virtual object EvalForever_Statement(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.STOP, 0) != null) return new BCBasic.Forever (BCBasic.Forever.ForeverType.Stop);
        	if (this.GetValue(tree, TokenType.WAIT, 0) != null) return new BCBasic.Forever (BCBasic.Forever.ForeverType.Wait);
        	return new BCBasic.Forever (BCBasic.Forever.ForeverType.Wait); // Default is to wait
        }

        protected virtual object EvalFunction_Statement(ParseTree tree, params object[] paramlist)
        {
            var arglist = new BCBasic.FunctionArglistDefine();
        	for (int i=1; i<99999; i++)
        	{
        		if (this.GetValue(tree, TokenType.VARIABLE, i)==null) break;
        		arglist.AddArg(this.GetValue(tree, TokenType.VARIABLE, i) as string);
        	}
        	var cmd = new BCBasic.Function (this.GetValue(tree, TokenType.VARIABLE, 0) as string, arglist);
        	return cmd;
        }

        protected virtual object EvalGlobal_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Global (this.GetValue(tree, TokenType.VARIABLE, 0) as String);
        }

        protected virtual object EvalGosub_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Gosub (this.GetValue(tree, TokenType.INTEGER, 0) as string);
        }

        protected virtual object EvalGoto_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Goto (this.GetValue(tree, TokenType.INTEGER, 0) as string);
        }

        protected virtual object EvalElse_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Else();
        }

        protected virtual object EvalEndIf_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.EndIf();
        }

        protected virtual object EvalIf_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.If (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.Statement, 0) as BCBasic.IStatement, this.GetValue(tree, TokenType.Statement, 1) as BCBasic.IStatement);
        }

        protected virtual object EvalImport_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Import (this.GetValue(tree, TokenType.FUNCTIONS, 0) as String, this.GetValue(tree, TokenType.StringValue, 0) as String);
        }

        protected virtual object EvalInput_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Input (this.GetValue(tree, TokenType.VARIABLE, 0) as String);
        }

        protected virtual object EvalLet_Statement(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.EQUALS, 0) != null)
        	{
        		var lhs = this.GetValue(tree, TokenType.VariableOrFunctionCall, 0);
        		var vv = lhs as BCBasic.VariableValue;
        		BCBasic.IExpression exp = null;
        		if (this.GetValue(tree, TokenType.Expression, 0) != null) exp = this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression;
        		else if (this.GetValue(tree, TokenType.COLOR, 0) != null) exp = new BCBasic.StringConstant (this.GetValue(tree, TokenType.COLOR, 0) as String);
        		if (vv != null)
        		{
        			var name = vv.VariableName;
        			return new BCBasic.Let (name, exp); 
        		}
        		var array = lhs as BCBasic.VariableArrayValue;
        		var fnc = lhs as BCBasic.NumericFunction;
        		if (fnc != null)
        		{
        			// Construct an 'arrray' out of the function
        			array = new BCBasic.VariableArrayValue(fnc.Function, fnc.ArgList);
        		}
        		if (array != null)
        		{
        			return new BCBasic.Let (array, exp); 
        		}
        	}
        	else // No equals, must be a function call
        	{
        		return new BCBasic.Call(this.GetValue(tree, TokenType.VariableOrFunctionCall, 0) as BCBasic.IExpression);
        	}
        	return null; // ok?
        }

        protected virtual object EvalExpression_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Let ("", this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalNext_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Next (this.GetValue(tree, TokenType.VARIABLE, 0) as string);
        }

        protected virtual object EvalPaper_Statement(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.COLOR, 0) != null) return new BCBasic.Paper (this.GetValue(tree, TokenType.COLOR, 0) as string);
        	if (this.GetValue(tree, TokenType.Expression, 0) != null) return new BCBasic.Paper (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        	return new BCBasic.Paper();
        }

        protected virtual object EvalPause_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Pause (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalPlay_Statement(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.STOP, 0) != null) return new BCBasic.Play (BCBasic.Play.PlayType.Stop);
        	if (this.GetValue(tree, TokenType.WAIT, 0) != null) return new BCBasic.Play (BCBasic.Play.PlayType.Wait);
        	if (this.GetValue(tree, TokenType.ONNOTE, 0) != null) return new BCBasic.Play (BCBasic.Play.PlayType.OnNote, this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        	return new BCBasic.Play (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalPrint_Expression(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.AT, 0) == null) return new BCBasic.PrintExpression (BCBasic.PrintExpression.PrintSpaceType.Default, new BCBasic.NumericConstant (-1), new BCBasic.NumericConstant (-1), this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        	return new BCBasic.PrintExpression (BCBasic.PrintExpression.PrintSpaceType.Newline, this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.Expression, 1) as BCBasic.IExpression, this.GetValue(tree, TokenType.Expression, 2) as BCBasic.IExpression);
        }

        protected virtual object EvalPrint_Statement(ParseTree tree, params object[] paramlist)
        {
            var list = new List<BCBasic.PrintExpression>();
        	if (this.GetValue(tree, TokenType.Print_Expression, 0) != null) list.Add (this.GetValue(tree, TokenType.Print_Expression, 0) as BCBasic.PrintExpression);
        	int ncomma = 0;
        	int nsemicolon = 0;
        	for (int i=1; i<99999; i++)
        	{
        		if (this.GetValue(tree, TokenType.COMMA, ncomma)==null && this.GetValue(tree, TokenType.SEMICOLON, nsemicolon)==null && this.GetValue(tree, TokenType.Print_Expression, i)==null) 
        		{
        			break;
        		}
        		var item = this.GetValue(tree, TokenType.Print_Expression, i) as BCBasic.PrintExpression;
        		if (item == null) item = new BCBasic.PrintExpression (BCBasic.PrintExpression.PrintSpaceType.Newline, new BCBasic.NumericConstant (-1), new BCBasic.NumericConstant (-1), null);
        		if (this.GetValue(tree, TokenType.COMMA, ncomma) != null) { ncomma++; item.CurrSpaceType = BCBasic.PrintExpression.PrintSpaceType.Tab; }
        		if (this.GetValue(tree, TokenType.SEMICOLON, nsemicolon) != null) { nsemicolon++; item.CurrSpaceType = BCBasic.PrintExpression.PrintSpaceType.NoSpace; }
        		list.Add (item);
        	}
        	return new BCBasic.PrintAt (list);
        }

        protected virtual object EvalRand_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Rand (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalRead_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Read (new BCBasic.VariableValue(this.GetValue(tree, TokenType.VARIABLE, 0) as string));
        }

        protected virtual object EvalRem_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Rem(this.GetValue(tree, TokenType.RESTOFLINE, 0) as string);
        }

        protected virtual object EvalReturn_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Return(this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalSpeak_Statement(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.LIST, 0) != null && this.GetValue(tree, TokenType.VOICES, 0) != null) return new BCBasic.SpeakListVoices();
        	if (this.GetValue(tree, TokenType.VOICE, 0) != null) return new BCBasic.Speak (this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.Expression, 1) as BCBasic.IExpression);
        	return new BCBasic.Speak (null, this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalStop_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.Stop(this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        }

        protected virtual object EvalStatement(ParseTree tree, params object[] paramlist)
        {
            return this.Nodes[0].Eval(tree);
        }

        protected virtual object EvalFull_Statement(ParseTree tree, params object[] paramlist)
        {
            return new BCBasic.FullStatement (this.GetValue(tree, TokenType.LINE_NUMBER, 0) as string, this.GetValue(tree, TokenType.Statement, 0) as BCBasic.IStatement);
        }

        protected virtual object EvalProgram(ParseTree tree, params object[] paramlist)
        {
            var p = new BCBasic.BCBasicProgram(); 
        	for (int i=0; i<99999; i++) 
        		{ 
        		var fs = this.GetValue(tree, TokenType.Full_Statement, i); 
        		if (fs==null) break; 
        		p.AddStatement (fs as BCBasic.FullStatement); 
        		} 
        	return p;
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            return this.GetValue(tree, TokenType.Program, 0) as BCBasic.BCBasicProgram;
        }

        protected virtual object EvalStringValue(ParseTree tree, params object[] paramlist)
        {
            var str = this.GetValue(tree, TokenType.STRING, 0)!= null ? this.GetValue(tree, TokenType.STRING, 0) as string : this.GetValue(tree, TokenType.SMARTQUOTESTRING, 0) as string;
        	//if (this.GetValue(tree, TokenType.STRING, 0) != null) str = str.Replace ("\"", "");
        	//else str = str.Replace ("“", "").Replace ("”", "");
               str = str.Substring (1, str.Length-2); // Remove the start and end quotes
               // Replacement rules: ""--> " ““-->“  ””-->” “”-->“
        	str = str.Replace ("\"\"", "\"");
        	str = str.Replace ("““", "“");
        	str = str.Replace ("””", "”");
        	str = str.Replace ("“”", "“");
        	str = str.Replace ("&QUOT;", "\"");
        	return str;
        }

        protected virtual object EvalVariableOrFunctionCall(ParseTree tree, params object[] paramlist)
        {
            // Definition of VariableOrFunctionCall
        	if (this.GetValue(tree, TokenType.VARIABLE, 0) != null && this.GetValue(tree, TokenType.LPAREN, 0) != null) 
        	{
        		var f = new BCBasic.NumericFunction (this.GetValue(tree, TokenType.VARIABLE, 0) as string);
        		for (int i=0; i<99999; i++)
        		{
        			var exp = this.GetValue(tree, TokenType.Expression, i) as BCBasic.IExpression;
        			if (exp == null) break;
        			f.ArgList.Add (exp);
        		}
        		return f;
        	}
        	if (this.GetValue(tree, TokenType.VARIABLE, 0) != null && this.GetValue(tree, TokenType.LSQUARE, 0) != null) 
        	{
        		return new BCBasic.VariableArrayValue (this.GetValue(tree, TokenType.VARIABLE, 0) as string, this.GetValue(tree, TokenType.Expression, 0) as BCBasic.IExpression);
        	}
        	if (this.GetValue(tree, TokenType.VARIABLE, 0) != null) return new BCBasic.VariableValue(this.GetValue(tree, TokenType.VARIABLE, 0) as string);
        	return null;
        }

        protected virtual object EvalConstant(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.NUMBER, 0) != null) return new BCBasic.NumericConstant (this.GetValue(tree, TokenType.NUMBER, 0) as string); 
        	if (this.GetValue(tree, TokenType.INFINITY, 0) != null) return new BCBasic.NumericConstant (Double.PositiveInfinity);
        	if (this.GetValue(tree, TokenType.HEX, 0) != null) 
        	{
        		var hexstr = (this.GetValue(tree, TokenType.HEX, 0) as string).Substring (2);
        		UInt32 hexvalue = 0;
        		var ok = UInt32.TryParse(hexstr, System.Globalization.NumberStyles.AllowHexSpecifier, null, out hexvalue);
        		return new BCBasic.NumericConstant (hexvalue); 
        	}
        	if (this.GetValue(tree, TokenType.StringValue, 0) != null) return new BCBasic.StringConstant (this.GetValue(tree, TokenType.StringValue, 0) as string); 
        	return new BCBasic.NumericConstant(Double.NaN);
        }

        protected virtual object EvalConstantList(ParseTree tree, params object[] paramlist)
        {
            var Retval = new List<BCBasic.IExpression>();
        	for (int i=0; i<99999; i++)
        	{
        		var con = this.GetValue(tree, TokenType.Constant, i) as BCBasic.IExpression;
        		if (con == null) break;
        		Retval.Add (con);
        	}
        	return Retval;
        }

        protected virtual object EvalExpressionAtom(ParseTree tree, params object[] paramlist)
        {
            // Variables MUST have the exact same name requirements as functions.
        	var n = this.GetValue(tree, TokenType.NUMBER, 0);
        	//var v = $ VARIABLE;
        	var l = this.GetValue(tree, TokenType.LPAREN, 0);
        	var e = this.GetValue(tree, TokenType.Expression, 0);
        
        	if (this.GetValue(tree, TokenType.NUMBER, 0) != null) return new BCBasic.NumericConstant (this.GetValue(tree, TokenType.NUMBER, 0) as string); 
        	if (this.GetValue(tree, TokenType.INFINITY, 0) != null) return new BCBasic.NumericConstant (Double.PositiveInfinity);
        	if (this.GetValue(tree, TokenType.HEX, 0) != null) 
        	{
        		var hexstr = (this.GetValue(tree, TokenType.HEX, 0) as string).Substring (2);
        		UInt32 hexvalue = 0;
        		var ok = UInt32.TryParse(hexstr, System.Globalization.NumberStyles.AllowHexSpecifier, null, out hexvalue);
        		return new BCBasic.NumericConstant (hexvalue); 
        	}
        	if (this.GetValue(tree, TokenType.StringValue, 0) != null) return new BCBasic.StringConstant (this.GetValue(tree, TokenType.StringValue, 0) as string); 
        
        	if (this.GetValue(tree, TokenType.Expression, 0) != null) return this.GetValue(tree, TokenType.Expression, 0); // Handles both () and [] cases
        	if (this.GetValue(tree, TokenType.VariableOrFunctionCall, 0) != null) return this.GetValue(tree, TokenType.VariableOrFunctionCall, 0);
        	return null;
        }

        protected virtual object EvalExpressionP12(ParseTree tree, params object[] paramlist)
        {
            // You can do PRINT LN EXP 2 and expect to see 2 printed out.
        	if (this.GetValue(tree, TokenType.POWER, 0) != null)
        	{
        		double power = 2.0; // POWER -> @"(²|³|⁴)";
        		switch (this.GetValue(tree, TokenType.POWER, 0) as string)
        		{
        		case "²": power = 2.0; break;
        		case "³": power = 3.0; break;
        		case "⁴": power = 4.0; break;
        		}
        		return new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionAtom, 0) as BCBasic.IExpression, "**", new BCBasic.NumericConstant(power));
        	}
        	if (this.GetValue(tree, TokenType.ROOT, 0) != null)
        	{
        		var power = 2;
        		switch (this.GetValue(tree, TokenType.ROOT, 0) as string)
        		{
        		case "√": power = 2; break;
        		case "∛": power = 3; break;
        		case "∜": power = 4; break;
        		}
        		return new BCBasic.InfixExpression (new BCBasic.NumericConstant(power), "√", this.GetValue(tree, TokenType.ExpressionP12, 0) as BCBasic.IExpression);
        	}
        	return this.GetValue(tree, TokenType.ExpressionAtom, 0);
        }

        protected virtual object EvalExpressionP11(ParseTree tree, params object[] paramlist)
        {
            // You can do PRINT LN EXP 2 and expect to see 2 printed out.
        	if (this.GetValue(tree, TokenType.MINUS, 0) != null) 
        	{
        		return new BCBasic.InfixExpression (new BCBasic.NumericConstant(0), "-", this.GetValue(tree, TokenType.ExpressionP11, 0) as BCBasic.IExpression);
        	}
        	if (this.GetValue(tree, TokenType.SINCLAIROP, 0) != null) 
        	{
        		var f = new BCBasic.NumericFunction (this.GetValue(tree, TokenType.SINCLAIROP, 0) as string);
        		f.ArgList.Add (this.GetValue(tree, TokenType.ExpressionP11, 0) as BCBasic.IExpression);
        		return f;
        	}
        	return this.GetValue(tree, TokenType.ExpressionP12, 0);
        }

        protected virtual object EvalExpressionP10(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.OPP10, 0)== null) return this.GetValue(tree, TokenType.ExpressionP11, 0);
        	var left = new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionP11, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.OPP10, 0) as string, this.GetValue(tree, TokenType.ExpressionP11, 1) as BCBasic.IExpression);
        	for (int i=2; i<9999; i++)
        	{
        		var exp = this.GetValue(tree, TokenType.ExpressionP11, i)  as BCBasic.IExpression;
        		if (exp == null) break;
        		left = new BCBasic.InfixExpression (left, this.GetValue(tree, TokenType.OPP10, i-1) as string, exp);
        	}
        	return left;
        }

        protected virtual object EvalExpressionP9(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.OPP9, 0) == null) return this.GetValue(tree, TokenType.ExpressionP10, 0);
        	var left = new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionP10, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.OPP9, 0) as string, this.GetValue(tree, TokenType.ExpressionP10, 1) as BCBasic.IExpression);
        	for (int i=2; i<9999; i++)
        	{
        		var exp = this.GetValue(tree, TokenType.ExpressionP10, i)  as BCBasic.IExpression;
        		if (exp == null) break;
        		left = new BCBasic.InfixExpression (left, this.GetValue(tree, TokenType.OPP9, i-1) as string, exp);
        	}
        	return left;
        }

        protected virtual object EvalExpressionP6(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.OPP6, 0) == null) return this.GetValue(tree, TokenType.ExpressionP9, 0);
        	var left = new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionP9, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.OPP6, 0) as string, this.GetValue(tree, TokenType.ExpressionP9, 1) as BCBasic.IExpression);
        	for (int i=2; i<9999; i++)
        	{
        		var exp = this.GetValue(tree, TokenType.ExpressionP9, i)  as BCBasic.IExpression;
        		if (exp == null) break;
        		left = new BCBasic.InfixExpression (left, this.GetValue(tree, TokenType.OPP6, i-1) as string, exp);
        	}
        	return left;
        }

        protected virtual object EvalExpressionP5(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.OPP5, 0) == null) return this.GetValue(tree, TokenType.ExpressionP6, 0);
        	var left = new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionP6, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.OPP5, 0) as string, this.GetValue(tree, TokenType.ExpressionP6, 1) as BCBasic.IExpression);
        	for (int i=2; i<9999; i++)
        	{
        		var exp = this.GetValue(tree, TokenType.ExpressionP6, i)  as BCBasic.IExpression;
        		if (exp == null) break;
        		left = new BCBasic.InfixExpression (left, this.GetValue(tree, TokenType.OPP5, i-1) as string, exp);
        	}
        	return left;
        }

        protected virtual object EvalExpressionEquality(ParseTree tree, params object[] paramlist)
        {
            var equality = new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionP6, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.OPP5, 0) as string, this.GetValue(tree, TokenType.ExpressionP6, 1) as BCBasic.IExpression);
        	return equality;
        }

        protected virtual object EvalExpressionP4(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.OPP4, 0) == null) return this.GetValue(tree, TokenType.ExpressionP5, 0);
        	var left = new BCBasic.NumericSingleExpression (this.GetValue(tree, TokenType.OPP4, 0) as string, this.GetValue(tree, TokenType.ExpressionP5, 0) as BCBasic.IExpression);
        	return left;
        }

        protected virtual object EvalExpressionP3(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.OPP3, 0) == null) return this.GetValue(tree, TokenType.ExpressionP4, 0);
        	var left = new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionP4, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.OPP3, 0) as string, this.GetValue(tree, TokenType.ExpressionP4, 1) as BCBasic.IExpression);
        	for (int i=2; i<9999; i++)
        	{
        		var exp = this.GetValue(tree, TokenType.ExpressionP4, i)  as BCBasic.IExpression;
        		if (exp == null) break;
        		left = new BCBasic.InfixExpression (left, this.GetValue(tree, TokenType.OPP3, i-1) as string, exp);
        	}
        	return left;
        }

        protected virtual object EvalExpressionP2(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.OPP2, 0) == null) return this.GetValue(tree, TokenType.ExpressionP3, 0);
        	var left = new BCBasic.InfixExpression (this.GetValue(tree, TokenType.ExpressionP3, 0) as BCBasic.IExpression, this.GetValue(tree, TokenType.OPP2, 0) as string, this.GetValue(tree, TokenType.ExpressionP3, 1) as BCBasic.IExpression);
        	for (int i=2; i<9999; i++)
        	{
        		var exp = this.GetValue(tree, TokenType.ExpressionP3, i)  as BCBasic.IExpression;
        		if (exp == null) break;
        		left = new BCBasic.InfixExpression (left, this.GetValue(tree, TokenType.OPP2, i-1) as string, exp);
        	}
        	return left;
        }

        protected virtual object EvalInputExpression(ParseTree tree, params object[] paramlist)
        {
            BCBasic.IExpression prompt = null;
        	BCBasic.IExpression defaultValue = null;
        	int idx = 0;
        	if (this.GetValue(tree, TokenType.DEFAULT, 0) != null) defaultValue = this.GetValue(tree, TokenType.Expression, idx++) as BCBasic.IExpression;
        	if (this.GetValue(tree, TokenType.PROMPT, 0) != null) prompt = this.GetValue(tree, TokenType.Expression, idx++) as BCBasic.IExpression;
        
        	return new BCBasic.NumericInput (prompt, defaultValue);
        }

        protected virtual object EvalExpression(ParseTree tree, params object[] paramlist)
        {
            return this.Nodes[0].Eval(tree);
        }


    }
    
    #endregion ParseTree
}
