// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace TinyPG
{
    #region Scanner

    public partial class Scanner
    {
        public string Input;
        public int StartPos = 0;
        public int EndPos = 0;
        public int CurrentLine;
        public int CurrentColumn;
        public int CurrentPosition;
        public List<Token> Skipped; // tokens that were skipped
        public Dictionary<TokenType, Regex> Patterns;

        private Token LookAheadToken;
        private List<TokenType> Tokens;
        private List<TokenType> SkipList; // tokens to be skipped

        public Scanner()
        {
            Regex regex;
            Patterns = new Dictionary<TokenType, Regex>();
            Tokens = new List<TokenType>();
            LookAheadToken = null;
            Skipped = new List<Token>();

            SkipList = new List<TokenType>();
            SkipList.Add(TokenType.WHITESPACE);

            regex = new Regex(@"ASSERT", RegexOptions.Compiled);
            Patterns.Add(TokenType.ASSERT, regex);
            Tokens.Add(TokenType.ASSERT);

            regex = new Regex(@"BEEP", RegexOptions.Compiled);
            Patterns.Add(TokenType.BEEP, regex);
            Tokens.Add(TokenType.BEEP);

            regex = new Regex(@"CALL", RegexOptions.Compiled);
            Patterns.Add(TokenType.CALL, regex);
            Tokens.Add(TokenType.CALL);

            regex = new Regex(@"CLS", RegexOptions.Compiled);
            Patterns.Add(TokenType.CLS, regex);
            Tokens.Add(TokenType.CLS);

            regex = new Regex(@"CONSOLE", RegexOptions.Compiled);
            Patterns.Add(TokenType.CONSOLE, regex);
            Tokens.Add(TokenType.CONSOLE);

            regex = new Regex(@"DATA", RegexOptions.Compiled);
            Patterns.Add(TokenType.DATA, regex);
            Tokens.Add(TokenType.DATA);

            regex = new Regex(@"DIM", RegexOptions.Compiled);
            Patterns.Add(TokenType.DIM, regex);
            Tokens.Add(TokenType.DIM);

            regex = new Regex(@"DUMP", RegexOptions.Compiled);
            Patterns.Add(TokenType.DUMP, regex);
            Tokens.Add(TokenType.DUMP);

            regex = new Regex(@"ELSE", RegexOptions.Compiled);
            Patterns.Add(TokenType.ELSE, regex);
            Tokens.Add(TokenType.ELSE);

            regex = new Regex(@"END IF", RegexOptions.Compiled);
            Patterns.Add(TokenType.ENDIF, regex);
            Tokens.Add(TokenType.ENDIF);

            regex = new Regex(@"END", RegexOptions.Compiled);
            Patterns.Add(TokenType.END, regex);
            Tokens.Add(TokenType.END);

            regex = new Regex(@"FOR", RegexOptions.Compiled);
            Patterns.Add(TokenType.FOR, regex);
            Tokens.Add(TokenType.FOR);

            regex = new Regex(@"FOREVER", RegexOptions.Compiled);
            Patterns.Add(TokenType.FOREVER, regex);
            Tokens.Add(TokenType.FOREVER);

            regex = new Regex(@"FUNCTION", RegexOptions.Compiled);
            Patterns.Add(TokenType.FUNCTION, regex);
            Tokens.Add(TokenType.FUNCTION);

            regex = new Regex(@"GLOBAL", RegexOptions.Compiled);
            Patterns.Add(TokenType.GLOBAL, regex);
            Tokens.Add(TokenType.GLOBAL);

            regex = new Regex(@"GOSUB", RegexOptions.Compiled);
            Patterns.Add(TokenType.GOSUB, regex);
            Tokens.Add(TokenType.GOSUB);

            regex = new Regex(@"GOTO", RegexOptions.Compiled);
            Patterns.Add(TokenType.GOTO, regex);
            Tokens.Add(TokenType.GOTO);

            regex = new Regex(@"IF", RegexOptions.Compiled);
            Patterns.Add(TokenType.IF, regex);
            Tokens.Add(TokenType.IF);

            regex = new Regex(@"IMPORT", RegexOptions.Compiled);
            Patterns.Add(TokenType.IMPORT, regex);
            Tokens.Add(TokenType.IMPORT);

            regex = new Regex(@"INPUT", RegexOptions.Compiled);
            Patterns.Add(TokenType.INPUT, regex);
            Tokens.Add(TokenType.INPUT);

            regex = new Regex(@"LET", RegexOptions.Compiled);
            Patterns.Add(TokenType.LET, regex);
            Tokens.Add(TokenType.LET);

            regex = new Regex(@"NEXT", RegexOptions.Compiled);
            Patterns.Add(TokenType.NEXT, regex);
            Tokens.Add(TokenType.NEXT);

            regex = new Regex(@"PAPER", RegexOptions.Compiled);
            Patterns.Add(TokenType.PAPER, regex);
            Tokens.Add(TokenType.PAPER);

            regex = new Regex(@"PAUSE", RegexOptions.Compiled);
            Patterns.Add(TokenType.PAUSE, regex);
            Tokens.Add(TokenType.PAUSE);

            regex = new Regex(@"PLAY", RegexOptions.Compiled);
            Patterns.Add(TokenType.PLAY, regex);
            Tokens.Add(TokenType.PLAY);

            regex = new Regex(@"PRINT", RegexOptions.Compiled);
            Patterns.Add(TokenType.PRINT, regex);
            Tokens.Add(TokenType.PRINT);

            regex = new Regex(@"RAND", RegexOptions.Compiled);
            Patterns.Add(TokenType.RAND, regex);
            Tokens.Add(TokenType.RAND);

            regex = new Regex(@"READ", RegexOptions.Compiled);
            Patterns.Add(TokenType.READ, regex);
            Tokens.Add(TokenType.READ);

            regex = new Regex(@"RETURN", RegexOptions.Compiled);
            Patterns.Add(TokenType.RETURN, regex);
            Tokens.Add(TokenType.RETURN);

            regex = new Regex(@"REM", RegexOptions.Compiled);
            Patterns.Add(TokenType.REM, regex);
            Tokens.Add(TokenType.REM);

            regex = new Regex(@"SPEAK", RegexOptions.Compiled);
            Patterns.Add(TokenType.SPEAK, regex);
            Tokens.Add(TokenType.SPEAK);

            regex = new Regex(@"STOP", RegexOptions.Compiled);
            Patterns.Add(TokenType.STOP, regex);
            Tokens.Add(TokenType.STOP);

            regex = new Regex(@"AT", RegexOptions.Compiled);
            Patterns.Add(TokenType.AT, regex);
            Tokens.Add(TokenType.AT);

            regex = new Regex(@"DEFAULT", RegexOptions.Compiled);
            Patterns.Add(TokenType.DEFAULT, regex);
            Tokens.Add(TokenType.DEFAULT);

            regex = new Regex(@"FROM", RegexOptions.Compiled);
            Patterns.Add(TokenType.FROM, regex);
            Tokens.Add(TokenType.FROM);

            regex = new Regex(@"FUNCTIONS", RegexOptions.Compiled);
            Patterns.Add(TokenType.FUNCTIONS, regex);
            Tokens.Add(TokenType.FUNCTIONS);

            regex = new Regex(@"LIST", RegexOptions.Compiled);
            Patterns.Add(TokenType.LIST, regex);
            Tokens.Add(TokenType.LIST);

            regex = new Regex(@"ONNOTE", RegexOptions.Compiled);
            Patterns.Add(TokenType.ONNOTE, regex);
            Tokens.Add(TokenType.ONNOTE);

            regex = new Regex(@"PROMPT", RegexOptions.Compiled);
            Patterns.Add(TokenType.PROMPT, regex);
            Tokens.Add(TokenType.PROMPT);

            regex = new Regex(@"STEP", RegexOptions.Compiled);
            Patterns.Add(TokenType.STEP, regex);
            Tokens.Add(TokenType.STEP);

            regex = new Regex(@"THEN", RegexOptions.Compiled);
            Patterns.Add(TokenType.THEN, regex);
            Tokens.Add(TokenType.THEN);

            regex = new Regex(@"TO", RegexOptions.Compiled);
            Patterns.Add(TokenType.TO, regex);
            Tokens.Add(TokenType.TO);

            regex = new Regex(@"VOICE", RegexOptions.Compiled);
            Patterns.Add(TokenType.VOICE, regex);
            Tokens.Add(TokenType.VOICE);

            regex = new Regex(@"VOICES", RegexOptions.Compiled);
            Patterns.Add(TokenType.VOICES, regex);
            Tokens.Add(TokenType.VOICES);

            regex = new Regex(@"WAIT", RegexOptions.Compiled);
            Patterns.Add(TokenType.WAIT, regex);
            Tokens.Add(TokenType.WAIT);

            regex = new Regex(@"(SGN)|(ABS)|(SIN)|(COS)|(TAN)|(ASN)|(ACS)|(ATN)|(LN)|(EXP)|(SQR)|(INT)|(LEN)|(STR\$)|(CODE)|(CHR\$)|(VAL)", RegexOptions.Compiled);
            Patterns.Add(TokenType.zzSINCLAIROP, regex);
            Tokens.Add(TokenType.zzSINCLAIROP);

            regex = new Regex(@"(LEN)|(STR\$)|(CODE)|(CHR\$)", RegexOptions.Compiled);
            Patterns.Add(TokenType.SINCLAIROP, regex);
            Tokens.Add(TokenType.SINCLAIROP);

            regex = new Regex(@"(BLACK)|(BLUE)|(RED)|(MAGENTA)|(GREEN)|(CYAN)|(YELLOW)|(WHITE)|(NONE)", RegexOptions.Compiled);
            Patterns.Add(TokenType.COLOR, regex);
            Tokens.Add(TokenType.COLOR);

            regex = new Regex(@"0x[0-9a-fA-F]*", RegexOptions.Compiled);
            Patterns.Add(TokenType.HEX, regex);
            Tokens.Add(TokenType.HEX);

            regex = new Regex(@"[-−–]?[0-9]*[.]?[0-9]+(E[-−–]?[0-9]+)*", RegexOptions.Compiled);
            Patterns.Add(TokenType.NUMBER, regex);
            Tokens.Add(TokenType.NUMBER);

            regex = new Regex(@"∞", RegexOptions.Compiled);
            Patterns.Add(TokenType.INFINITY, regex);
            Tokens.Add(TokenType.INFINITY);

            regex = new Regex(@"\""([^""]|(\""\""))*\""", RegexOptions.Compiled);
            Patterns.Add(TokenType.STRING, regex);
            Tokens.Add(TokenType.STRING);

            regex = new Regex(@"\“([^“”]|(\”\”)|(\“\“))*\”", RegexOptions.Compiled);
            Patterns.Add(TokenType.SMARTQUOTESTRING, regex);
            Tokens.Add(TokenType.SMARTQUOTESTRING);

            regex = new Regex(@"[0-9]+", RegexOptions.Compiled);
            Patterns.Add(TokenType.INTEGER, regex);
            Tokens.Add(TokenType.INTEGER);

            regex = new Regex(@"[0-9]+", RegexOptions.Compiled);
            Patterns.Add(TokenType.LINE_NUMBER, regex);
            Tokens.Add(TokenType.LINE_NUMBER);

            regex = new Regex(@"[\r\n\v]+", RegexOptions.Compiled);
            Patterns.Add(TokenType.CR, regex);
            Tokens.Add(TokenType.CR);

            regex = new Regex(@"=", RegexOptions.Compiled);
            Patterns.Add(TokenType.EQUALS, regex);
            Tokens.Add(TokenType.EQUALS);

            regex = new Regex(@"OR", RegexOptions.Compiled);
            Patterns.Add(TokenType.OPP2, regex);
            Tokens.Add(TokenType.OPP2);

            regex = new Regex(@"AND", RegexOptions.Compiled);
            Patterns.Add(TokenType.OPP3, regex);
            Tokens.Add(TokenType.OPP3);

            regex = new Regex(@"NOT", RegexOptions.Compiled);
            Patterns.Add(TokenType.OPP4, regex);
            Tokens.Add(TokenType.OPP4);

            regex = new Regex(@"(<=|>=|<>|<|=|≅|≇|>)", RegexOptions.Compiled);
            Patterns.Add(TokenType.OPP5, regex);
            Tokens.Add(TokenType.OPP5);

            regex = new Regex(@"(\+|-|−|–)", RegexOptions.Compiled);
            Patterns.Add(TokenType.OPP6, regex);
            Tokens.Add(TokenType.OPP6);

            regex = new Regex(@"(\*|×|⋅|·|/)", RegexOptions.Compiled);
            Patterns.Add(TokenType.OPP9, regex);
            Tokens.Add(TokenType.OPP9);

            regex = new Regex(@"(\*\*)", RegexOptions.Compiled);
            Patterns.Add(TokenType.OPP10, regex);
            Tokens.Add(TokenType.OPP10);

            regex = new Regex(@"(-|−|–)", RegexOptions.Compiled);
            Patterns.Add(TokenType.MINUS, regex);
            Tokens.Add(TokenType.MINUS);

            regex = new Regex(@"(√|∛|∜)", RegexOptions.Compiled);
            Patterns.Add(TokenType.ROOT, regex);
            Tokens.Add(TokenType.ROOT);

            regex = new Regex(@"(²|³|⁴)", RegexOptions.Compiled);
            Patterns.Add(TokenType.POWER, regex);
            Tokens.Add(TokenType.POWER);

            regex = new Regex(@",", RegexOptions.Compiled);
            Patterns.Add(TokenType.COMMA, regex);
            Tokens.Add(TokenType.COMMA);

            regex = new Regex(@";", RegexOptions.Compiled);
            Patterns.Add(TokenType.SEMICOLON, regex);
            Tokens.Add(TokenType.SEMICOLON);

            regex = new Regex(@"\(", RegexOptions.Compiled);
            Patterns.Add(TokenType.LPAREN, regex);
            Tokens.Add(TokenType.LPAREN);

            regex = new Regex(@"\)", RegexOptions.Compiled);
            Patterns.Add(TokenType.RPAREN, regex);
            Tokens.Add(TokenType.RPAREN);

            regex = new Regex(@"\[", RegexOptions.Compiled);
            Patterns.Add(TokenType.LSQUARE, regex);
            Tokens.Add(TokenType.LSQUARE);

            regex = new Regex(@"\]", RegexOptions.Compiled);
            Patterns.Add(TokenType.RSQUARE, regex);
            Tokens.Add(TokenType.RSQUARE);

            regex = new Regex(@"[a-zA-Z][a-zA-Z0-9_]*([.][a-zA-Z][a-zA-Z0-9_]*)*\$?", RegexOptions.Compiled);
            Patterns.Add(TokenType.VARIABLE, regex);
            Tokens.Add(TokenType.VARIABLE);

            regex = new Regex(@"[^\r\n\v]*", RegexOptions.Compiled);
            Patterns.Add(TokenType.RESTOFLINE, regex);
            Tokens.Add(TokenType.RESTOFLINE);

            regex = new Regex(@"^\s*$", RegexOptions.Compiled);
            Patterns.Add(TokenType.EOF, regex);
            Tokens.Add(TokenType.EOF);

            regex = new Regex(@"([ \t\u2690\u2691\u26f3\u26ff\ud83c\udf8c\ud83c\udfc1\ud83c\udff3\ud83c\udff4\ud83d\udcea\ud83d\udceb\ud83d\udcec\ud83d\udced\ud83d\udea9]*[\u21B2\u21b5\u2936][ \t\v\n\r\u2690\u2691\u26f3\u26ff\ud83c\udf8c\ud83c\udfc1\ud83c\udff3\ud83c\udff4\ud83d\udcea\ud83d\udceb\ud83d\udcec\ud83d\udced\ud83d\udea9]*)|[ \t\u2690\u2691\u26f3\u26ff\ud83c\udf8c\ud83c\udfc1\ud83c\udff3\ud83c\udff4\ud83d\udcea\ud83d\udceb\ud83d\udcec\ud83d\udced\ud83d\udea9]+", RegexOptions.Compiled);
            Patterns.Add(TokenType.WHITESPACE, regex);
            Tokens.Add(TokenType.WHITESPACE);


        }

        public void Init(string input)
        {
            this.Input = input;
            StartPos = 0;
            EndPos = 0;
            CurrentLine = 0;
            CurrentColumn = 0;
            CurrentPosition = 0;
            LookAheadToken = null;
        }

        public Token GetToken(TokenType type)
        {
            Token t = new Token(this.StartPos, this.EndPos);
            t.Type = type;
            return t;
        }

         /// <summary>
        /// executes a lookahead of the next token
        /// and will advance the scan on the input string
        /// </summary>
        /// <returns></returns>
        public Token Scan(params TokenType[] expectedtokens)
        {
            Token tok = LookAhead(expectedtokens); // temporarely retrieve the lookahead
            LookAheadToken = null; // reset lookahead token, so scanning will continue
            StartPos = tok.EndPos;
            EndPos = tok.EndPos; // set the tokenizer to the new scan position
            return tok;
        }

        /// <summary>
        /// returns token with longest best match
        /// </summary>
        /// <returns></returns>
        public Token LookAhead(params TokenType[] expectedtokens)
        {
            int i;
            int startpos = StartPos;
            Token tok = null;
            List<TokenType> scantokens;


            // this prevents double scanning and matching
            // increased performance
            if (LookAheadToken != null 
                && LookAheadToken.Type != TokenType._UNDETERMINED_ 
                && LookAheadToken.Type != TokenType._NONE_) return LookAheadToken;

            // if no scantokens specified, then scan for all of them (= backward compatible)
            if (expectedtokens.Length == 0)
                scantokens = Tokens;
            else
            {
                scantokens = new List<TokenType>(expectedtokens);
                scantokens.AddRange(SkipList);
            }

            do
            {

                int len = -1;
                TokenType index = (TokenType)int.MaxValue;
                string input = Input.Substring(startpos);

                tok = new Token(startpos, EndPos);

                for (i = 0; i < scantokens.Count; i++)
                {
                    Regex r = Patterns[scantokens[i]];
                    Match m = r.Match(input);
                    if (m.Success && m.Index == 0 && ((m.Length > len) || (scantokens[i] < index && m.Length == len )))
                    {
                        len = m.Length;
                        index = scantokens[i];  
                    }
                }

                if (index >= 0 && len >= 0)
                {
                    tok.EndPos = startpos + len;
                    tok.Text = Input.Substring(tok.StartPos, len);
                    tok.Type = index;
                }
                else if (tok.StartPos < tok.EndPos - 1)
                {
                    tok.Text = Input.Substring(tok.StartPos, 1);
                }

                if (SkipList.Contains(tok.Type))
                {
                    startpos = tok.EndPos;
                    Skipped.Add(tok);
                }
                else
                {
                    // only assign to non-skipped tokens
                    tok.Skipped = Skipped; // assign prior skips to this token
                    Skipped = new List<Token>(); //reset skips
                }
            }
            while (SkipList.Contains(tok.Type));

            LookAheadToken = tok;
            return tok;
        }
    }

    #endregion

    #region Token

    public enum TokenType
    {

            //Non terminal tokens:
            _NONE_  = 0,
            _UNDETERMINED_= 1,

            //Non terminal tokens:
            Assert_Statement= 2,
            Beep_Statement= 3,
            Call_Statement= 4,
            Cls_Statement= 5,
            Console_Statement= 6,
            Data_Statement= 7,
            Dim_Statement= 8,
            Dump_Statement= 9,
            For_Statement= 10,
            Forever_Statement= 11,
            Function_Statement= 12,
            Global_Statement= 13,
            Gosub_Statement= 14,
            Goto_Statement= 15,
            Else_Statement= 16,
            EndIf_Statement= 17,
            If_Statement= 18,
            Import_Statement= 19,
            Input_Statement= 20,
            Let_Statement= 21,
            Expression_Statement= 22,
            Next_Statement= 23,
            Paper_Statement= 24,
            Pause_Statement= 25,
            Play_Statement= 26,
            Print_Expression= 27,
            Print_Statement= 28,
            Rand_Statement= 29,
            Read_Statement= 30,
            Rem_Statement= 31,
            Return_Statement= 32,
            Speak_Statement= 33,
            Stop_Statement= 34,
            Statement= 35,
            Full_Statement= 36,
            Program = 37,
            Start   = 38,
            StringValue= 39,
            VariableOrFunctionCall= 40,
            Constant= 41,
            ConstantList= 42,
            ExpressionAtom= 43,
            ExpressionP12= 44,
            ExpressionP11= 45,
            ExpressionP10= 46,
            ExpressionP9= 47,
            ExpressionP6= 48,
            ExpressionP5= 49,
            ExpressionEquality= 50,
            ExpressionP4= 51,
            ExpressionP3= 52,
            ExpressionP2= 53,
            InputExpression= 54,
            Expression= 55,

            //Terminal tokens:
            ASSERT  = 56,
            BEEP    = 57,
            CALL    = 58,
            CLS     = 59,
            CONSOLE = 60,
            DATA    = 61,
            DIM     = 62,
            DUMP    = 63,
            ELSE    = 64,
            ENDIF   = 65,
            END     = 66,
            FOR     = 67,
            FOREVER = 68,
            FUNCTION= 69,
            GLOBAL  = 70,
            GOSUB   = 71,
            GOTO    = 72,
            IF      = 73,
            IMPORT  = 74,
            INPUT   = 75,
            LET     = 76,
            NEXT    = 77,
            PAPER   = 78,
            PAUSE   = 79,
            PLAY    = 80,
            PRINT   = 81,
            RAND    = 82,
            READ    = 83,
            RETURN  = 84,
            REM     = 85,
            SPEAK   = 86,
            STOP    = 87,
            AT      = 88,
            DEFAULT = 89,
            FROM    = 90,
            FUNCTIONS= 91,
            LIST    = 92,
            ONNOTE  = 93,
            PROMPT  = 94,
            STEP    = 95,
            THEN    = 96,
            TO      = 97,
            VOICE   = 98,
            VOICES  = 99,
            WAIT    = 100,
            zzSINCLAIROP= 101,
            SINCLAIROP= 102,
            COLOR   = 103,
            HEX     = 104,
            NUMBER  = 105,
            INFINITY= 106,
            STRING  = 107,
            SMARTQUOTESTRING= 108,
            INTEGER = 109,
            LINE_NUMBER= 110,
            CR      = 111,
            EQUALS  = 112,
            OPP2    = 113,
            OPP3    = 114,
            OPP4    = 115,
            OPP5    = 116,
            OPP6    = 117,
            OPP9    = 118,
            OPP10   = 119,
            MINUS   = 120,
            ROOT    = 121,
            POWER   = 122,
            COMMA   = 123,
            SEMICOLON= 124,
            LPAREN  = 125,
            RPAREN  = 126,
            LSQUARE = 127,
            RSQUARE = 128,
            VARIABLE= 129,
            RESTOFLINE= 130,
            EOF     = 131,
            WHITESPACE= 132
    }

    public class Token
    {
        private int startpos;
        private int endpos;
        private string text;
        private object value;

        // contains all prior skipped symbols
        private List<Token> skipped;

        public int StartPos { 
            get { return startpos;} 
            set { startpos = value; }
        }

        public int Length { 
            get { return endpos - startpos;} 
        }

        public int EndPos { 
            get { return endpos;} 
            set { endpos = value; }
        }

        public string Text { 
            get { return text;} 
            set { text = value; }
        }

        public List<Token> Skipped { 
            get { return skipped;} 
            set { skipped = value; }
        }
        public object Value { 
            get { return value;} 
            set { this.value = value; }
        }

        [XmlAttribute]
        public TokenType Type;

        public Token()
            : this(0, 0)
        {
        }

        public Token(int start, int end)
        {
            Type = TokenType._UNDETERMINED_;
            startpos = start;
            endpos = end;
            Text = ""; // must initialize with empty string, may cause null reference exceptions otherwise
            Value = null;
        }

        public void UpdateRange(Token token)
        {
            if (token.StartPos < startpos) startpos = token.StartPos;
            if (token.EndPos > endpos) endpos = token.EndPos;
        }

        public override string ToString()
        {
            if (Text != null)
                return Type.ToString() + " '" + Text + "'";
            else
                return Type.ToString();
        }
    }

    #endregion
}
